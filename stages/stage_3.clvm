;; "IR" means "intermediate representation"... essentially a tagged s-expression
;; a tagged s-expression (t-exp) is (tag . val) where val is also a t-exp
;; An "IR" is a t-exp where tag is of the form
;;  TYPE or (TYPE . offset) if we know the offset (the default value of -1 is returned otherwise, meaning "unknown")
;;  TYPE is one of "CONS", "NULL", "INT", "HEX", "DQT" (double-quoted string), "SQT" (single-quoted string), "SYM" (symbol)

(mod sexp

  (defmacro not (a)
      (qq (i (unquote a) 0 1))
  )

  ; boolean or macro
  (defmacro or ARGS
      (if ARGS
          (qq (if (unquote (f ARGS))
              1
              (unquote (c or (r ARGS)))
          ))
      0)
  )

  ;; ir utilities

  (defun ir_new (type val)
    (c type val)
  )

  (defun ir_first ((A . B))
    ;; do "first" on IR
    (f B)
  )

  (defun ir_rest ((A . B))
    ;; "rest" on an IR
    (r B)
  )

  (defun ir_cons (A B)
    ;; build an IR out of two IRs
    (c "CONS" (c A B))
  )

  (defun ir_null ()
    ;; the "null" ir
    (c "NULL" ())
  )

  (defun ir_type ((A . val))
    ;; return the type of the IR
    (if (l A)
      (f A)
      A
    )
  )

  ;;
  (defun BROKEN_ir_list A
    (if A
      (ir_null)
      (ir_cons (ir_new "HEX" (ir_first A)) (ir_list (ir_rest A)))
    )
  )

  (defun ir_as_atom ((A . B))
    B
  )

  (defun ir_listp (A)
    (= "CONS" (ir_type A))
  )

  (defun ir_nullp (A)
    (= "NULL" (ir_type A))
  )


  (defun ir_offset ((type_offset_pair . val))
    ;; return the offset of the IR, or -1 if unknown
    (if (l type_offset_pair)
      (r type_offset_pair)
      -1
    )
  )

  ;; this section deals with macro expansion
  ;; macro_lookup is an IR list of elements of the form (symbol . code)
  ;; where `symbol` is a macro name and `code` is the code to be run to expand this macro

  (defun macro_expand (sexp macro_lookup)
    (if (ir_listp sexp)
      (macro_expand_call (macro_expand (ir_first sexp) macro_lookup) (ir_rest sexp) macro_lookup macro_lookup)
      sexp
    )
  )

  (defun macro_expand_call (operator args macro_lookup macros_remaining)
    (if (or (ir_listp operator) (ir_nullp macros_remaining))
      (ir_cons operator (macro_expand_args args macro_lookup))
      (if (= (ir_as_atom operator) (ir_as_atom (ir_first (ir_first macros_remaining))))
        ;; we need to expand this macro
        ;; TODO: rename this nonsense "call" (and have it operate on CODE)
        ((c (ir_as_atom (ir_rest (ir_first macros_remaining))) args))
        (macro_expand_call (operator args macro_lookup (ir_rest macros_remaining)))
      )
    )
  )

  (defun macro_expand_args (args macro_lookup)
    (if (ir_listp args)
      (ir_cons (macro_expand (ir_first args) macro_lookup) (macro_expand_args (ir_rest args) macro_lookup))
      args
    )
  )

  ;; go through and "compile" atoms, by quoting them

  (defun compile-atoms (sexp)
    (if (ir_listp sexp)
      (ir_cons (compile-atoms (ir_first sexp)) (compile-atoms (ir_rest sexp)))
      (if (is-compilable-atom (ir_type sexp)) (ir_cons (ir_new "OP" "q") (ir_cons sexp (ir_null))) sexp)
    )
  )

  (defun is-compilable-atom (type)
    (or (= type "INT") (= type "HEX") (= type "DQT") (= type "SQT") (= type "QT"))
  )

  ;; this section deals with "expansion"
  ;; When an sexp (in IR) is expanded,
  ;; it returns a pair (A . B) where A is the
  ;; recursively sexp and B is a list of all
  ;; symbols in the sexp (symbols are not unique in the list)


  (defun exp_call (op args acc)
    ;; this is a call
    (ir_cons (ir_new "OP" (ir_as_atom (ir_first sexp)))
      (exp_args (ir_rest sexp acc))
    )
  )

  (defun exp_acc (sexp acc_exp acc_sym is_op)
    (if (ir_nullp sexp)
      (ir_cons acc_exp acc_sym)
      (if (ir_listp sexp)
        "UNKNOWN"
        (if (= (ir_type sexp) "SYM")
          (if is_op
            (ir_cons (ir_new "OP" (ir_as_atom sexp)) acc_sym)
            (ir_cons sexp (ir_cons sexp acc_sym))
          )
          (ir_cons sexp acc_sym)
        )
      )
    )
  )

  ;; get rid of "NODE" ir_sexp

  (defun compile-node (ir_sexp)
    (if (ir_listp ir_sexp)
      (ir_cons (compile-node (ir_first ir_sexp)) (compile-node (ir_rest ir_sexp)))
      (if (= (ir_type ir_sexp) "NODE")
        (ir_new "CODE" (_node_index_to_path ir_sexp))
        ir_sexp
      )
    )
  )

  ;; return an IR list of symbols used in an sexp (recursively)
  ;; the returned values is every symbol, in order, without repeats removed

  (defun flatten-symbols-acc (sexp acc)
    (if (ir_nullp sexp)
      acc
      (if (ir_listp sexp)
        (flatten-symbols-acc (ir_first sexp) (flatten-symbols-acc (ir_rest sexp) acc))
        (if
          (= (ir_type sexp) "SYM")
          (ir_cons sexp acc)
          acc
        )
      )
    )
  )

  (defun flatten-symbols (sexp)
    (flatten-symbols-acc sexp (ir_null))
  )

  ;; a hack way to invoke the python version of _compile_lambda

  (defun com-lamb (args code)
    (_compile_lambda args code (flatten-symbols args) (flatten-symbols code))
  )

  (defun exp (sexp) (exp_acc sexp (ir_null) (ir_null) 0))
  
  ;(macro_expand sexp (ir_null))
  ;(compile-node sexp) ; -i ((AAA BBB CCC) (+ AAA BBB CCC))
  (_codegen_mod_context (_mod_context_for_mod sexp))
  ;; (com-lamb (ir_first sexp) (ir_first (ir_rest sexp)))
  ;; com -t '((AAA BBB CCC) (+ AAA BBB CCC))'
  ;(_full_path_for_name sexp)
)
